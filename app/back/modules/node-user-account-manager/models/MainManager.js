/**************************************************
* An Nodejs module for MongoDB entities manager   *
***************************************************/

/**************************************************
*                   Dependencies                  *
***************************************************/
var NodeMongodbManager = require('../../node-mongodb-manager/nmm');
var ObjectID = require('mongodb').ObjectID;

/**
* @author Macky Dieng
* @license MIT - http://opensource.org/licenses/MIT
* @copyright 2016 the author
*
* Represents a MainManager
* @constructor
* @param {string} idKey - the key to use for identify document in database
* @param {string} collection - the collection of the current manager
* @param {Object} Entity - The entity of the current manager
*/
function MainManager (collection, Entity) {

  /**
  * The database instance variable
  */
  var db = new NodeMongodbManager().getDB();

  /**
  * The field to use for identify document in database collection
  */
  var idKey = '_id';

  /**
  * List of persisted objects
  */
  var listEntity = new Array();

  /**
  * Object filter for custome query
  */
  var filter = {};

  /***Error variable***/
  var error = {};

  /**
  * Private method, allows to display errors
  * @param msg {string} message - message to display in the error
  */
  var displayErr = function(msg) {
    var err = {code:400, messgae:msg };
    console.log('Errors occurred in MainManager...');
    console.log(err);
  }
  if(collection==null) {
    displayErr('You must specify collection to use in your current manager');
    return;
  }
  if(Entity==null) {
    displayErr('You must specify entity to use in your current manager');
    return;
  }
  /**
  * Private helper method, allows to parse document coming from database
  * @param {Object} doc - document to parse
  * @return Object
  **/
  var getParsedDoc = function(doc) {
    doc.id = doc._id; /***Creating correct attr id since doc._id generated by mongodb***/
    delete doc._id; /***Now we can delete the _id on the document***/
    var entity = new Entity(doc);
    return entity;
  }
  /**
  * Private helper method, allows to check if callback is specified in current function
  * @param {string} func - the current function name
  * @param {string} callback - the callback to check for
  */
  var isCallbackMissed = function(callback,func) {
    if (!callback || typeof callback !=='function') {
        displayErr('You must specify an callback function as \n\
        parameter to the ' + func + ' method');
        return true;
    } else {
        return false;
    }
  }
  /**
  * Allows to retrive a single object in collection from database
  * @param {object} id - the unique identify of object to retrive
  * @param {function} callback - function to call after the treatment
  */
  this.findOne = function(id,callback) {
    if (!id || typeof id == 'function') {
      displayErr('You must specify the id parameter on method "findOne"');
      return;
    }
    if(isCallbackMissed(callback,"findOne")) {
      return;
    }
    filter[idKey] = new ObjectID(id);/****Getting the document id from MongoDB ObjectID constructor****/
    db.collection(collection).findOne(filter,{}, function(err, doc) {
      if(err) {
        console.log(err);
      }
      if (doc!=null) {
        var entity = getParsedDoc(doc);
        callback(entity);
      } else {
        displayErr('No entry corresponding to the current request');
        callback(doc);
        filter = [];
        return;
      }
    });
    filter = []; /***Clearning the filter object***/
  }
  /**
  * Allows to retrive one object in collection by filter
  * @param {Object}  filter - filter to use for the request
  * @param {function} callback - function to call after the treatment
  */
  this.findOneBy = function(filter,callback) {
    if (!filter || typeof filter=='function') {
      displayErr('You must specify the filter parameter on method findOneBy');
      return;
    }
    if(isCallbackMissed(callback,"findOneBy")) {
      return;
    }
    db.collection(collection).findOne(filter,{}, function(err, doc) {
      if(err) {
        console.log(err);
      }
      if(doc!==null) {
        var entity = getParsedDoc(doc);
        callback(entity);
      } else {
        displayErr('No entry corresponding to the current request');
        callback(doc);
      }
    });
  }
  /**
  * Allows to retrive all entries of given collection
  * @param {function} callback - function to call after the treatment
  **/
  this.findAll = function(callback) {
    if(isCallbackMissed(callback,"findAll")) {
      return;
    }
    db.collection(collection).find(filter).toArray(function(err, docs) {
      if(err) {
        console.log(err);
      }
      if(docs.length > 0) {
        var objects = new Array();
        for(i in docs) {
          var entity = getParsedDoc(doc);
          objects.push(entity);
        }
        callback(objects);
      } else {
        displayErr('No entry corresponding to the current request');
        callback(docs);
      }
    });
  }
  /**
  * Allows to retrieve many objects in collection by criteria
  * @param {Object}  filter - the filter to use for the request
  * @param {function} callback - function to call after the treatment
  */
  this.findAllBy = function(filter, callback) {
    if(!filter || typeof filter == 'function') {
      displayErr('You must specify the filter parameter on method findAllBy');
      return;
    }
    if(isCallbackMissed(callback,"findAllBy")) {
      return;
    }
    db.collection(collection).find(filter).toArray(function(err, docs) {
      if(err) {
        console.log(err);
      }
      if(docs.length > 0) {
        var objects = new Array();
        for(i in docs) {
          var entity = getParsedDoc(doc);
          objects.push(entity);
        }
        callback(objects);
      } else {
        displayErr('No entry corresponding to the current request');
        callback(docs);
      }
    });
  }
  /**
  * Private method, allows to parse all gieven objects and prepare them
  * for insertion in database
  * @param {function} callback - function to call when everything went well
  */
  var oParser = function(callback) {
    if(isCallbackMissed(callback,"oParser")) {
      return;
    }
    var oTab = new Array();
    for(i in listEntity) {
      var data = {};
      var object = listEntity[i]; //Current entity in the loop (can be any type of object)
      var attribut = null;
      var getter = null;
      var objectId = null;
      for(method in object) {
        if(/set/.test(method)) {
          attribut = method.substring(3,method.length); /***Will return "FirstName" for "setFirstName"**/
          attribut = attribut.charAt(0).toLowerCase() + attribut.slice(1); /***Will return "firstName" for "FirstName"*/
          getter = 'get'+attribut.charAt(0).toUpperCase() + attribut.slice(1); //Will return "getFirstName" for firstName
          if (getter!='getId') { /***Object id is null here so o.getId() will return null*/
            /***
             * The following line equals to data['firstName'] = Entity.getFirstName()
             * for Entity object iterating in the loop
             */
            data[attribut] = object[getter]();
          } else {
            objectId = object[getter](); /***Storing separatly the object id for updateing mode*/
          }
        }
      }
      if(data.length < 1) {
        displayErr('The setters of all objects must imperatively \n\
        be preceded by the string "set"');
        return;
      }
      oTab.push({id: objectId, d: data}); /***Storing current object in the loop*/
    }
    callback(oTab); /***When everything went well, callback is called for accessing the data*/
  }
  /**
  * Allows to save all persited objects
  */
  this.save = function() {
    if(listEntity.length < 1) {
      displayErr('No object has been persisted, \n\
      you can\'t invoke save() method if there are no object to save');
      return;
    }
    oParser(function(oData) {
      for(i in oData) {
        if(oData[i].id!==null) { /***Update mode, object id is not null (objec already exists)*/
          filter[idKey] = new ObjectID(oData[i].id);
          db.collection(collection).updateOne(filter,{$set:oData[i].d},function(err, result) {
            if (err) {
              console.error(err);
            }
            console.log(result);
          });
        } else { /***insert mode, object id is null (new object)*/
          db.collection(collection).insertOne(oData[i].d, function(err, result) {
            if (err) {
              console.error(err);
            }
          });
        }
      }
    });
    listEntity = []; /***Clearning the objects list after current saving done*/
  }
  /**
  * Allows to remove an specific object
  * @param {Object} o - the object to remove
  * @param {funtion} callback - the function to call when everything went well
  */
  this.remove = function(o, callback) {
    if (!o) {
      displayErr('You must specify the object to delete as \n\
      parameter on the remove method');
      return;
    }
    if (o['getId'] !==null && typeof o.getId === 'function') {
      filter[idKey] = new ObjectID(o.getId());
    } else {
        displayErr("The current object passed for delete \n\
        does'nt have an getId method");
        return;
    }
    if(isCallbackMissed(callback,"remove")) {
      return;
    }
    db.collection(collection).removeOne(filter, {w:1}, function(err, res) {
      if(err) {
        console.log(err);
      }
      if(callback) {
        callback(res);
      }
    });
  }
  /**
  * Allows to retrieve many object by custome filter
  * @param {Object} filter - the filter to execute for the custome query
  * @param {funtion} callback - the function to call when everything went well
  */
  this.findByCustomefilter = function(filter, callback) {

  }
  /**
  * Allows to persist given objects
  * @param {Object} entity - the object to persist
  */
  this.persist = function(entity) {
    if(entity==null) {
      displayErr('You must specify the entity to persist \n\
      as parameter on "persist" method');
      return;
    }
    listEntity.push(entity);
  }
  /**
  * Allows to persist given objects
  * @param {Object} - the object to persist
  */
  this.unpersist = function(entity) {
    listEntity.splice(entity,1);
  }
}
/***Exporting the module***/
module.exports = MainManager;
